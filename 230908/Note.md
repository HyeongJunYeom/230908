# 230908

---

## STL 알고리즘

>	>	 자료찾기는 MSDN기반으로 하면 좋다.


>	정렬, 검색 등을 제공하는 자료 구조 기반의 함수 템플릿

>	Stl 알고리즘의 헤더파일

```cpp
#include <algorithm>

sort(begin, end, 조건자);	//	정렬을 수행해주는 알고리즘 ( 함수처럼 보이지만 함수 템플릿 )
							//	즉슨 사용하면 템플릿 함수

							//	퀵정렬 기반으로 만들어짐
for_each(vecIntP.begin(), vecIntP.end(), Safe_Delete<int*>);
vecIntP.clear();				//	컨테이너를 순회하는 알고리즘 (for문)

						//	일반적인 for문보다 빠르다.

						//	즉슨 for문보다 for_each(); 를 사용할 것

count_if ();
//	컨테이너의 원소를 순회하면서 매개 변수로 넘겨받는 결과가 
true일때의 개수를 반환하는 알고리즘


find_if	();		//	반환타입이 iterator 타입
//	조건자에 해당하는 원소를 탐색하여 반환하는 알고리즘

//	map같은 컨테이너에서 key값등을 이용하여 많이 쓰임(연관컨테이너류)

```

>	list 컨테이너는 별도의 멤버함수로 sort()를 가지고있음 (퀵정렬 기반)

>	함수객체 헤더파일

```cpp
#include <functional>

	//	함수 객체들을 만들어놓은 헤더파일
```

>	list

```cpp
#include <list>

list<int>		intList;		//	양방향 리스트 기반
// vector<int>		vecInt;

push_front();		//	벡터에는 없는 멤버함수
//	맨 앞에 요소를 추가하는 함수;

pop_front();
```

### 리스트의 벡터와의 차이

	1. 임의접근을 허용하지 않음 ( 순차 접근만 허용 )

	2. 중간 삽입 삭제 시 단순 노드끼리 포인터로 연결하거나 연결을 해제하면 그만이기 때문에 vector와 같이 
	메모리 공간을 밀고 당길 일이 없다.

	3. 한번 삽입 위치를 찾게 되면 그 이후의 삽입 삭제에는 '상수 시간 복잡도'의 성능

	4. 탐색하고자 하는 위치를 찾으려면 원소 개수만큼의 '선형적 시간 복잡도'를 갖는다.

	5. 배열기반이 아니므로 대괄호연산자가 오버로딩되어있지않다. 추상적으로만 배열의 형태일뿐
	실제 메모리는 흩어져있다.

	6. 나중에 길찾기등에 있어서 인덱스를 뒤집을때 push_front, pop_front를 사용...(아직은 이해안감)

	7. 양방향 반복자 이므로 iter + 2; 와같은 임의접근연산이 불가능하다.
	++iter; 를 두번하등으로 iter의 위치를 이동시켜야한다.

	8. sort함수를 멤버 함수로 지니고있다.

	9. reverse(); 원소들의 위치를 반전시키는 함수.

	10. sprlice(); 잘라내기 함수
	잘 안쓰는 함수이다.